<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python E-Learning Platform</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Python Learning Platform</h1>
        <div class="tabs">
            <!-- Tab navigation -->
            <ul id="tab-list">
                <li class="tab active" onclick="changeTab(0)">Question 1</li>
                <li class="tab" onclick="changeTab(1)">Question 2</li>
                <li class="tab" onclick="changeTab(2)">Question 3</li>
                <li class="tab" onclick="changeTab(3)">Question 4</li>
                <li class="tab" onclick="changeTab(4)">Question 5</li>
                <li class="tab" onclick="changeTab(5)">Question 6</li>
                <li class="tab" onclick="changeTab(6)">Question 7</li>
                <li class="tab" onclick="changeTab(7)">Question 8</li>
                <li class="tab" onclick="changeTab(8)">Question 9</li>
                <li class="tab" onclick="changeTab(9)">Question 10</li>
                <li class="tab" onclick="changeTab(10)">Question 11</li>
                <li class="tab" onclick="changeTab(11)">Question 12</li>
                <li class="tab" onclick="changeTab(12)">Question 13</li>
                <li class="tab" onclick="changeTab(13)">Question 14</li>
                <li class="tab" onclick="changeTab(14)">Question 15</li>
            </ul>
        </div>

        <div class="tab-content">
            <!-- Tab content with Python editor -->
            <div class="tab-panel active">
                <h2>Question 1: 1. Create a program for recursive and non-recursive algorithms and examine the order of growth from log2n to n!.</h2>
                <textarea id="code-editor-1" class="code-editor">
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
def linear_search(arr, target):
    x=[i for i,j in enumerate(arr) if j==target]
    return x[0]
print(factorial(5))  # Output: 120
print(linear_search([1, 2, 5, 4, 3], 3))  # Output: 4
</textarea>
                <button onclick="runCode(0)">Run Code</button>
                <pre id="output-1" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 2: 2. Write a program using Divide and Conquer Strassen's Matrix Multiplication to multiply the two square matrices A and B, each of size n x n..</h2>
                <textarea id="code-editor-2" class="code-editor">
import numpy as np

# Define the matrices A and B (4x4 with padding already applied)
A = np.array([
    [1, 2, 3, 0],
    [3, 4, 5, 0],
    [5, 4, 3, 0],
    [0, 0, 0, 0]
])

B = np.array([
    [2, 2, 3, 0],
    [1, 4, 5, 0],
    [6, 4, 3, 0],
    [0, 0, 0, 0]
])

# Function to compute Strassen's products for 4x4 matrices
def strassen_simple(A, B):
    # Divide matrices into 2x2 quadrants
    A11, A12, A21, A22 = A[:2, :2], A[:2, 2:], A[2:, :2], A[2:, 2:]
    B11, B12, B21, B22 = B[:2, :2], B[:2, 2:], B[2:, :2], B[2:, 2:]

    # Compute the 7 products (no recursion)
    P1 = np.dot(A11 + A22, B11 + B22)
    P2 = np.dot(A21 + A22, B11)
    P3 = np.dot(A11, B12 - B22)
    P4 = np.dot(A22, B21 - B11)
    P5 = np.dot(A11 + A12, B22)
    P6 = np.dot(A21 - A11, B11 + B12)
    P7 = np.dot(A12 - A22, B21 + B22)

    # Combine results into quadrants of the resultant matrix
    C11 = P1 + P4 - P5 + P7
    C12 = P3 + P5
    C21 = P2 + P4
    C22 = P1 + P3 - P2 + P6

    # Assemble the 4x4 result matrix
    C = np.zeros((4, 4))
    C[:2, :2] = C11
    C[:2, 2:] = C12
    C[2:, :2] = C21
    C[2:, 2:] = C22

    return C

# Compute the product
result = strassen_simple(A, B)

# Display the result
print("Resultant Matrix:")
print(result)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 3: To solve the following topological sorting problem, develop a code based on the DFS method..</h2>
                <textarea id="code-editor-2" class="code-editor">
graph = {
    'a': ['b', 'e'],
    'b': ['c'],
    'd': ['a', 'b', 'c', 'e', 'g'],
    'e': ['g', 'f'],
    'g': ['c', 'f']
}
def dfs(node, visited):
    print(node, end=" ")  # Print the current node
    visited.add(node)  # Mark node as visited
    for neighbor in graph.get(node, []):
        if neighbor not in visited:
            dfs(neighbor, visited)

visited = set()
for node in graph:
    if node not in visited:
        dfs(node, visited)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 4: Given coins of denominations 1, 2, 4 and 5 with amount to be bay is 8. Create a program to find optimal number of coins and sequence of coins used to pay the given amount using dynamic programming method..</h2>
                <textarea id="code-editor-2" class="code-editor">
def min_coins(coins, amount):
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    for i in range(1, amount + 1):
        dp[i] = min(dp[i - c] + 1 for c in coins if i - c >= 0)
    return dp[amount], [c for c in coins if dp[amount] == dp[amount - c] + 1]

coins = [1, 2, 4, 5]
amount = 8
min_coins_needed, coin_sequence = min_coins(coins, amount)
print(f"Minimum coins needed: {min_coins_needed}")
print(f"Coin sequence: {coin_sequence}")
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 5: Write a program to discover the transitive closure of the digraph specified in the following adjacency matrix using Warshall's algorithm.</h2>
                <textarea id="code-editor-2" class="code-editor">
def transitive_closure(G):
    n = len(G)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                G[i][j] |= G[i][k] & G[k][j]  # In-place update
    return G

G = [[0, 1, 1, 1],
     [1, 0, 1, 1],
     [1, 1, 0, 1],
     [1, 1, 1, 0]]
for row in transitive_closure(G):
    print(row)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 6: Write a program to discover the transitive closure of the digraph specified in the following adjacency matrix using Warshall's algorithm [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]].</h2>
                <textarea id="code-editor-2" class="code-editor">
def transitive_closure(G):
    n = len(G)
    for k in range(n):
        for i in range(n):
            for j in range(n):
                G[i][j] |= G[i][k] & G[k][j]  # In-place update
    return G

G = [[0, 1, 1, 0],
     [0, 0, 1, 0],
     [0, 0, 0, 1],
     [1, 0, 0, 0]]
for row in transitive_closure(G):
    print(row)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 7:Write a program to find the shortest path between every pair of vertices of a graph using Floyd’s Algo.</h2>
                <textarea id="code-editor-2" class="code-editor">
def floyd_warshall(graph):
    n = len(graph)
    dist = [row[:] for row in graph]  # Initialize distance matrix
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][j] == 0: dist[i][j] = float('inf')  # Handle no path case
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
    return [[0 if dist[i][j] == float('inf') else dist[i][j] for j in range(n)] for i in range(n)]
graph = [
    [0, 5, 0, 0, 10, 0],
    [0, 0, 7, 12, 0, 0],
    [0, 0, 0, 8, 0, 0],
    [3, 0, 0, 0, 9, 6],
    [0, 0, 0, 0, 0, 20],
    [0, 0, 15, 0, 0, 0]
]
shortest_paths = floyd_warshall(graph)
for row in shortest_paths:
    print(row)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 8: 10. Create a program for the given instance of problem to obtain the optimal solution for the knapsack problem using Dynamic Programming..</h2>
                <textarea id="code-editor-2" class="code-editor">
def knapsack(w, p, W):
    dp = [0] * (W+1)
    for i in range(len(w)):
        for j in range(W, w[i]-1, -1):
            dp[j] = max(dp[j], dp[j-w[i]]+p[i])
    return dp[-1]
print(knapsack([2,3,4,5],[3, 4, 5,6], 5))
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 9:Write a program to solve the following knapsack instance using Dynamic Programming. N=3, [w1,w2,w3]=[1.2.2] and [p1,p2,p3]=[18,16,6] and Capacity W=4.</h2>
                <textarea id="code-editor-2" class="code-editor">
def knapsack(w, p, W):
    dp = [0] * (W+1)
    for i in range(len(w)):
        for j in range(W, w[i]-1, -1):
            dp[j] = max(dp[j], dp[j-w[i]]+p[i])
    return dp[-1]
print(knapsack([1, 2, 2], [18, 16, 6], 4))
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 10: Create a program using Greedy Technique for finding a shortest path from one node to another node in the following graph using Dijkstra’s algorithm..</h2>
                <textarea id="code-editor-2" class="code-editor">
import heapq

def dijkstra(graph, start):
    n = len(graph)
    dist = [float('inf')] * n
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        d, u = heapq.heappop(pq)
        if d > dist[u]: continue
        for v, w in enumerate(graph[u]):
            if w and dist[u] + w < dist[v]:
                dist[v] = dist[u] + w
                heapq.heappush(pq, (dist[v], v))

    return dist

graph = [
    [0, 6, 0, 0, 0, 0, 0, 9, 0],
    [6, 0, 8, 0, 0, 0, 0, 11, 0],
    [0, 8, 0, 7, 0, 4, 0, 0, 2],
    [0, 0, 7, 0, 9, 14, 0, 0, 0],
    [0, 0, 0, 9, 0, 10, 0, 0, 0],
    [0, 0, 4, 14, 10, 0, 2, 0, 0],
    [0, 0, 0, 0, 0, 2, 0, 1, 6],
    [9, 11, 0, 0, 0, 0, 1, 0, 7],
    [0, 0, 2, 0, 0, 0, 6, 7, 0]
]

distances = dijkstra(graph, 0)

for i, d in enumerate(distances):
    print(f"0 -> {i}: {d}")
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 11: Create a program using Greedy Techniques to Construct the Huffman’s Tree & code for the following data.</h2>
                <textarea id="code-editor-2" class="code-editor">
import heapq

freq = [('A', 0.1), ('B', 0.5), ('C', 0.35), ('D', 0.5), ('E', 0.4), ('-', 0.2)]
heap = [[w, s] for s, w in freq]
heapq.heapify(heap)

while len(heap) > 1:
    a, b = heapq.heappop(heap), heapq.heappop(heap)
    heapq.heappush(heap, [a[0] + b[0], [a, b]])

def get_codes(node, code=""):
    return {node[1]: code} if isinstance(node[1], str) else {**get_codes(node[1][0], code + "0"), **get_codes(node[1][1], code + "1")}

codes = get_codes(heap[0])
print(codes)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 12:Create a program to solve the following Farmers problem using simplex method.</h2>
                <textarea id="code-editor-2" class="code-editor">
from scipy.optimize import linprog
c = [-63, -90]
A,b = [[110, 40], [60, 110]], [20200, 30000]
result = linprog(c, A_ub=A, b_ub=b, bounds=[(0, None), (0, None)], method='simplex')
print(f"Acres of corn: {result.x[0]:.2f} 
 Soybeans: {result.x[1]:.2f}
 Profit: {-result.fun:.2f}") # put $ before {}
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 13: Create a program for N-Queen (5 Queen) problem using Backtracking.</h2>
                <textarea id="code-editor-2" class="code-editor">
def solve(board=None, row=0, n=8):
    if board is None:
        board = [-1] * n  # Initialize the board with -1 for empty positions
    if row == n: 
        print(board)
        return True  # Stop recursion after finding the first solution
    for col in range(n):
        if all(board[r] != col and abs(r - row) != abs(board[r] - col) for r in range(row)):
            board[row] = col
            if solve(board, row + 1, n): return True  # Found a solution, return True
solve(n=5)  # Example for n=4
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 14: There are 5 distinct numbers {1,2,5,6,8}. Find the combinations of these numbers such that sum is 9. Write a code using backtracking method to arrive at the solution.</h2>
                <textarea id="code-editor-2" class="code-editor">
def comb(nums, target, i=0, current=[]):
    if target == 0: print(current)
    for j in range(i, len(nums)):
        if nums[j] <= target: comb(nums, target-nums[j], j+1, current+[nums[j]])
comb([1, 2, 5, 6, 8], 9)
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <div class="tab-panel">
                <h2>Question 15: Create a program to solve the following tsp using branch and bound method.</h2>
                <textarea id="code-editor-2" class="code-editor">
from itertools import permutations
graph = [
    [0, 1, 3, float('inf')],
    [1, 0, 8, 5],
    [3, 8, 0, 2],
    [float('inf'), 5, 2, 0]
]
n = len(graph)
def tsp(graph):
    nodes = list(range(n))
    min_cost = float('inf')
    for perm in permutations(nodes[1:]):
        route = [0] + list(perm) + [0]
        cost = 0
        for i in range(len(route) - 1):
            cost += graph[route[i]][route[i + 1]]
            if cost >= min_cost:
                break
        min_cost = min(min_cost, cost)
    return min_cost
result = tsp(graph)
print(f"The minimum cost of the TSP is: {result}")
</textarea>
                <button onclick="runCode(1)">Run Code</button>
                <pre id="output-2" class="output"></pre>
            </div>
            <!-- Add 13 more tab-panels for other questions here -->
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>